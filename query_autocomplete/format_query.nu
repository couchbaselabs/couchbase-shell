# operators are the operators that can be used in conditions in a where clause
const $operators = [!= <= >= > < = LIKE]

# key_words are n1ql query keywords
const $key_words = [FROM SELECT WHERE AND LIMIT ANY EVERY IN SATISFIES END ORDER BY ASC DESC]

# format_query takes the list of inputs generated by the FROM custom completions and turns them into a valid n1ql query string
export def main [inputs: list] {
    # The brackets in meta().id get dropped so we need to add them back in
    # Also == needs to be replaced with =
    let $inputs = ($inputs | each {|it| if ($it == "meta.id") {"meta().id"} else if ($it == "==") {"="} else {$it}})

    mut $query = ([FROM $inputs.0] | str join " ")
    mut $clause = [SELECT]
    mut $first_field = true
    mut $is_value = false
    let $final_index = (($inputs | skip 2 | length) - 1)

    for $element in ($inputs | skip 2 | enumerate) {
        # If we see another keyword that is the end of the clause
        if ($element.item in $key_words) {
            $query = ([$query ...$clause ] | str join " ")
            $clause = [$element.item]
            $first_field = true
            continue
        }

        match $clause.0 {
            SELECT => {
                # When parsing the select clause we need to wrap all fields apart from * and meta().id in backticks
                # and separate them with commas
                mut $formatted_field = ", "

                if $first_field {
                    $formatted_field = ""
                    $first_field = false
                }

                if ($element.item in [* "meta().id"]) {
                     $formatted_field = ([$formatted_field $element.item] | str join)
                } else {
                     $formatted_field = ([$formatted_field "`" $element.item "`"] | str join)
                }

                $clause = ($clause | append $formatted_field)
            }
            WHERE | AND | SATISFIES => {
                if ($element.item in $operators) {
                    $clause = ($clause | append $element.item)
                    # If we see an operator then the next item will be the value in a condition clause
                    $is_value = true
                    continue
                }

                # When parsing the WHERE clause we need to wrap field names in backticks and condition values that are not
                # numbers in quotes
                mut $formatted_field = ""
                if $is_value {
                    if (is_number $element.item) {
                        $formatted_field = $element.item
                    } else {
                        $formatted_field = ([$formatted_field '"' $element.item '"'] | str join)
                    }
                    $is_value = false
                } else {
                    # If the element contains backticks that is because it is addressing the field of an object so
                    # we do not wrap in backticks again
                    if ($element.item | str contains "`") {
                         $formatted_field = $element.item
                    } else {
                        $formatted_field = ([$formatted_field "`" $element.item "`"] | str join)
                    }
                }

                $clause = ($clause | append $formatted_field)
            }
            LIMIT | ANY | EVERY | IN => {
                $clause = ($clause | append $element.item)
            }
        }
    }
    $query = ([$query ...$clause ] | str join " ")

    # If the query contains a where then it has to be re-formatted to have the SELECT clause at the start
    if ($query | str contains "WHERE") {
        let $from_clause = ($query | split row "SELECT" | first)
        let $select_clause = ($query | split row "WHERE" | split row SELECT | [SELECT $in.1] | str join)
        let $rest_of_query = ($query | split row "WHERE" | last | [WHERE $in] | str join)
        $query = ([$select_clause $from_clause $rest_of_query] | str join)
    }

    return $query
}

# is_number determines if a string is actually a string representation of an int or float
def is_number [possible_string: string] {
    # Try to convert the input to an int to see if it is actually a string representation of an int/float
    let $possible_int = (do --ignore-errors { $possible_string | into int })
    ($possible_int != null)
}